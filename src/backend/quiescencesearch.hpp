#pragma once

#include <cstdint>
#include <iostream>
#include <vector>
#include <type_traits>
#include <bit>
#include <bitset>

#include "bitboard.hpp"
#include "lookuptable.hpp"


//These functions are used in quiescence search to generate a subset of all moves, so that we can have non static depth in our search tree
//Mainly just mirrors of normal generation functions with slight differences
void generateWQuietMoves(const bitBoard &board, vector<bitBoard> &returnVector, const uint64_t &pinnedHorizontal, const uint64_t &pinnedVertical, 
                        const uint64_t &pinnedDiagonal, const uint64_t &pinnedOtherDiagonal, const uint64_t &pinnedPieces, const uint64_t &EnemyPieces,
                        const uint64_t &protectKing, const uint64_t &Empty, const uint64_t &unSafe, const uint64_t &occupied){
    
    //First we initialize all needed variables

    bitBoard placeholder;           //A copy of this is pushed into returnVector for each possible move
    uint64_t possibleMoves;         //Used to store were a onePiece can move to, has multiple set bits as possible move locations
    uint64_t possibleMove;          //Used to loop over all possibleMoves
    uint64_t onePiece;              //Used to loop over all the pieces in for example horses etc. Note pawns have no need for this since their moves are generated by just bitshifting all of them
    int iLocation;                  //Used as a location on board for given onePiece

    //List of all types of pinned pieces that are needed
    const uint64_t horPinnedPawns = board.wP & pinnedHorizontal;
    const uint64_t verPinnedPawns = board.wP & pinnedVertical;
    const uint64_t diagPinnedPawns = board.wP & pinnedDiagonal;
    const uint64_t diagOtherPinnedPawns = board.wP & pinnedOtherDiagonal;

    const uint64_t horPinnedQueens = board.wQ & pinnedHorizontal;
    const uint64_t verPinnedQueens = board.wQ & pinnedVertical;
    const uint64_t diagPinnedQueens = board.wQ & pinnedDiagonal;
    const uint64_t diagOtherPinnedQueens = board.wQ & pinnedOtherDiagonal;

    const uint64_t pinnedDiagonalBishops = board.wB & pinnedDiagonal;
    const uint64_t pinnedOtherDiagonalBishops = board.wB & pinnedOtherDiagonal;

    const uint64_t horPinnedRooks = board.wR & pinnedHorizontal;
    const uint64_t verPinnedRooks = board.wR & pinnedVertical;

    //Use these variables since board is a reference, NOTE, these variables are changed, and need to be "reset" before being used again
    uint64_t pawns;
    uint64_t horses;
    uint64_t bishops;
    uint64_t rooks;
    uint64_t queens;

    //Enemypieces by value
    const uint64_t enemy359     = board.bH | board.bB | board.bR | board.bQ;
    const uint64_t enemy59      = board.bR | board.bQ;
    const uint64_t enemy9       = board.bQ;
    const uint64_t enemy        = EnemyPieces;

    const uint64_t capturePieces = enemy;

    //Then we just generate all wanted moves, by calling the generator functions in movegenerator.hpp

    //Pawn promotions
    generateWPawnPromotions(pawns, EnemyPieces, protectKing, diagPinnedPawns, diagOtherPinnedPawns, Empty, possibleMoves, possibleMove, placeholder, 
                            board, pinnedPieces, returnVector);
    
    //King captures
    generateWKingCaptures(board.wK, capturePieces, unSafe, possibleMoves, possibleMove, iLocation, placeholder, board, returnVector);
    
    //Pawn captures
    generateWPawnCaptures(pawns, capturePieces, protectKing, diagPinnedPawns, diagOtherPinnedPawns, Empty, possibleMoves, possibleMove, 
                            placeholder, board, pinnedPieces, occupied, returnVector);
    
    //Horse moves capturing enemy pieces, note a pinned horse can NEVER move
    generateWHorseCaptures(horses, capturePieces, protectKing, possibleMoves, pinnedPieces, possibleMove, onePiece, iLocation, placeholder, board, returnVector);
    
    //Bishop captures
    generateWBishopCaptures(bishops, capturePieces, protectKing, possibleMoves, possibleMove, pinnedPieces, onePiece, occupied, iLocation, 
                            pinnedDiagonalBishops, pinnedOtherDiagonalBishops, placeholder, board, returnVector);

    //All rook captures
    generateWRookCaptures(rooks, capturePieces, protectKing, possibleMoves, possibleMove, pinnedPieces, onePiece, occupied, iLocation, horPinnedRooks, 
                            verPinnedRooks, placeholder, board, returnVector);

    //All queen captures
    generateWQueenCaptures(queens, capturePieces, protectKing, possibleMoves, possibleMove, pinnedPieces, onePiece, occupied, iLocation, horPinnedQueens, 
                            verPinnedQueens, diagPinnedQueens, diagOtherPinnedQueens, placeholder, board, returnVector);
    
}

void generateBQuietMoves(const bitBoard &board, vector<bitBoard> &returnVector, const uint64_t &pinnedHorizontal, const uint64_t &pinnedVertical, 
                        const uint64_t &pinnedDiagonal, const uint64_t &pinnedOtherDiagonal, const uint64_t &pinnedPieces, const uint64_t &EnemyPieces,
                        const uint64_t &protectKing, const uint64_t &Empty, const uint64_t &unSafe, const uint64_t &occupied){
    
    //Initialize all needed variables

    bitBoard placeholder;           //A copy of this is pushed into returnVector for each possible move
    uint64_t possibleMoves;         //Used to store were a onePiece can move to, has multiple set bits as possible move locations
    uint64_t possibleMove;          //Used to loop over all possibleMoves
    uint64_t onePiece;              //Used to loop over all the pieces in for example horses etc. Note pawns have no need for this since their moves are generated by just bitshifting all of them
    int iLocation;                  //Used in locating a certain piece, used to call 

    //List of all types of pinned pieces that are needed
    const uint64_t horPinnedPawns = board.bP & pinnedHorizontal;
    const uint64_t verPinnedPawns = board.bP & pinnedVertical;
    const uint64_t diagPinnedPawns = board.bP & pinnedDiagonal;
    const uint64_t diagOtherPinnedPawns = board.bP & pinnedOtherDiagonal;

    const uint64_t horPinnedQueens = board.bQ & pinnedHorizontal;
    const uint64_t verPinnedQueens = board.bQ & pinnedVertical;
    const uint64_t diagPinnedQueens = board.bQ & pinnedDiagonal;
    const uint64_t diagOtherPinnedQueens = board.bQ & pinnedOtherDiagonal;

    const uint64_t pinnedDiagonalBishops = board.bB & pinnedDiagonal;
    const uint64_t pinnedOtherDiagonalBishops = board.bB & pinnedOtherDiagonal;

    const uint64_t horPinnedRooks = board.bR & pinnedHorizontal;
    const uint64_t verPinnedRooks = board.bR & pinnedVertical;

    //Use these variables since board is a reference, NOTE, these variables are changed, and need to be "reset" if wanted to be used again
    uint64_t pawns;
    uint64_t horses;
    uint64_t bishops;
    uint64_t rooks;
    uint64_t queens;

    //Enemypieces
    const uint64_t enemy359     = board.wH | board.wB | board.wR | board.wQ;
    const uint64_t enemy59      = board.wR | board.wQ;
    const uint64_t enemy9       = board.wQ;
    const uint64_t enemy        = EnemyPieces;

    const uint64_t capturePieces = enemy;

    //Then we just generate all wanted moves, by calling the generator functions in movegenerator.hpp

    //Pawn promotions
    generateBPawnPromotions(pawns, EnemyPieces, protectKing, diagPinnedPawns, diagOtherPinnedPawns, Empty, possibleMoves, possibleMove, placeholder, 
                            board, pinnedPieces, returnVector);
    
    //King captures
    generateBKingCaptures(board.bK, capturePieces, unSafe, possibleMoves, possibleMove, iLocation, placeholder, board, returnVector);
    
    //Pawn captures
    generateBPawnCaptures(pawns, capturePieces, protectKing, diagPinnedPawns, diagOtherPinnedPawns, Empty, possibleMoves, possibleMove, 
                            placeholder, board, pinnedPieces, occupied, returnVector);
    
    //Horse moves capturing enemy pieces, note a pinned horse can NEVER move
    generateBHorseCaptures(horses, capturePieces, protectKing, possibleMoves, pinnedPieces, possibleMove, onePiece, iLocation, placeholder, board, returnVector);

    //Bishop captures
    generateBBishopCaptures(bishops, capturePieces, protectKing, possibleMoves, possibleMove, pinnedPieces, onePiece, occupied, iLocation, 
                            pinnedDiagonalBishops, pinnedOtherDiagonalBishops, placeholder, board, returnVector);

    //All rook captures
    generateBRookCaptures(rooks, capturePieces, protectKing, possibleMoves, possibleMove, pinnedPieces, onePiece, occupied, iLocation, horPinnedRooks, 
                            verPinnedRooks, placeholder, board, returnVector);

    //All queen captures
    generateBQueenCaptures(queens, capturePieces, protectKing, possibleMoves, possibleMove, pinnedPieces, onePiece, occupied, iLocation, horPinnedQueens, 
                            verPinnedQueens, diagPinnedQueens, diagOtherPinnedQueens, placeholder, board, returnVector);
    
}

void generateWhiteNonQuietMoves(bitBoard &b, vector<bitBoard> &allWhiteQMoves){
    
    b.eP &= ~Rank4;         //Clears all own enpassantable pawns
    
    //Set variables to be used in generating moves
    const uint64_t MyPieces = b.wP|b.wH|b.wB|b.wR|b.wQ|b.wK,
    EnemyPieces = b.bP|b.bH|b.bB|b.bR|b.bQ,
    MovableSquares = ~MyPieces,
    Occupied = MyPieces | EnemyPieces | b.bK,
    Empty = ~Occupied,
    UnSafe = unSafeWhite(b.bK, b.bQ, b.bB, b.bH, b.bR, b.bP, b.wK, Occupied),
    
    //Set pieces attacking own king
    attackingPieces = (((b.wK >> 7) & b.bP) & ~AFile) | (((b.wK >> 9) & b.bP) & ~HFile) |
                      threatHorses(b.wK, b.bH) |
                      threatDiag(b.wK, b.bB, b.bQ, Occupied) | 
                      threatHorVer(b.wK, b.bR, b.bQ, Occupied),
    
    //Set pinned pieces
    pinnedDiagonal = pinnedDiag(b.wK, MyPieces, b.bQ, b.bB, Occupied),
    pinnedOtherDiagonal = pinnedOtherDiag(b.wK, MyPieces, b.bQ, b.bB, Occupied),
    pinnedHorizontal = pinnedHor(b.wK, MyPieces, b.bQ, b.bR, Occupied),
    pinnedVertical = pinnedVer(b.wK, MyPieces, b.bQ, b.bR, Occupied),
    pinnedPieces = pinnedHorizontal | pinnedVertical | pinnedDiagonal | pinnedOtherDiagonal;
    
    const int numberOfAttackes = __builtin_popcountll(attackingPieces);       //Counts the amout of attackers

    if(numberOfAttackes > 1){
        generateWhiteKingMoves(b, allWhiteQMoves, EnemyPieces, UnSafe);
    }else if(numberOfAttackes == 1){
        int attackLoc = __builtin_ctzll(attackingPieces);
        int kingLoc = __builtin_ctzll(b.wK);
        //All the possible locations were a move can be made to uncheck the king, ie either capture the attacking piece or block it,
        const uint64_t protectKing = (diagMoves(attackLoc, Occupied) & diagMoves(kingLoc, Occupied)) | (otherDiagMoves(attackLoc, Occupied) & otherDiagMoves(kingLoc, Occupied)) |
                      (horMoves(attackLoc, Occupied) & horMoves(kingLoc, Occupied)) | (verMoves(attackLoc, Occupied) & verMoves(kingLoc, Occupied)) | attackingPieces;
        generateWQuietMoves(b, allWhiteQMoves, pinnedHorizontal, pinnedVertical, pinnedDiagonal, pinnedOtherDiagonal, pinnedPieces, EnemyPieces, protectKing, Empty, UnSafe, Occupied);
    }else{
        const uint64_t protectKing = ~0LL;
        generateWQuietMoves(b, allWhiteQMoves, pinnedHorizontal, pinnedVertical, pinnedDiagonal, pinnedOtherDiagonal, pinnedPieces, EnemyPieces, protectKing, Empty, UnSafe, Occupied);
    }
}

void generateBlackNonQuietMoves(bitBoard &b, vector<bitBoard> &allBlackQMoves){
    b.eP &= ~Rank5;         //Clears all own enpassantable pawns
    
    //Set variables to be used in generating moves
    const uint64_t MyPieces = b.bP|b.bH|b.bB|b.bR|b.bQ|b.bK,
    EnemyPieces = b.wP|b.wH|b.wB|b.wR|b.wQ,
    MovableSquares = ~MyPieces,
    Occupied = MyPieces | EnemyPieces | b.wK,
    Empty = ~Occupied,
    UnSafe = unSafeBlack(b.wK, b.wQ, b.wB, b.wH, b.wR, b.wP, b.bK, Occupied),
    
    //Set pieces attacking own king
    attackingPieces = (((b.bK << 7) & b.wP) & ~HFile) | (((b.bK << 9) & b.wP) & ~AFile) |
                      threatHorses(b.bK, b.wH) | 
                      threatDiag(b.bK, b.wB, b.wQ, Occupied) | 
                      threatHorVer(b.bK, b.wR, b.wQ, Occupied),
    
    //Set pinned pieces
    pinnedDiagonal = pinnedDiag(b.bK, MyPieces, b.wQ, b.wB, Occupied),
    pinnedOtherDiagonal = pinnedOtherDiag(b.bK, MyPieces, b.wQ, b.wB, Occupied),
    pinnedHorizontal = pinnedHor(b.bK, MyPieces, b.wQ, b.wR, Occupied),
    pinnedVertical = pinnedVer(b.bK, MyPieces, b.wQ, b.wR, Occupied),
    pinnedPieces = pinnedHorizontal | pinnedVertical | pinnedDiagonal | pinnedOtherDiagonal;

    const int numberOfAttackes = __builtin_popcountll(attackingPieces);       //Counts the amout of attackers

    if(numberOfAttackes > 1){
        generateBlackKingMoves(b, allBlackQMoves, EnemyPieces, UnSafe);
    }else if(numberOfAttackes == 1){
        int attackLoc = __builtin_ctzll(attackingPieces);
        int kingLoc = __builtin_ctzll(b.bK);
        //All the possible locations were a move can be made to uncheck the king, ie either capture the attacking piece or block it,
        const uint64_t protectKing = (diagMoves(attackLoc, Occupied) & diagMoves(kingLoc, Occupied)) | (otherDiagMoves(attackLoc, Occupied) & otherDiagMoves(kingLoc, Occupied)) |
                      (horMoves(attackLoc, Occupied) & horMoves(kingLoc, Occupied)) | (verMoves(attackLoc, Occupied) & verMoves(kingLoc, Occupied)) | attackingPieces;
        generateBQuietMoves(b, allBlackQMoves, pinnedHorizontal, pinnedVertical, pinnedDiagonal, pinnedOtherDiagonal, pinnedPieces, EnemyPieces, protectKing, Empty, UnSafe, Occupied);
    }else{
        const uint64_t protectKing = ~0LL;
        generateBQuietMoves(b, allBlackQMoves, pinnedHorizontal, pinnedVertical, pinnedDiagonal, pinnedOtherDiagonal, pinnedPieces, EnemyPieces, protectKing, Empty, UnSafe, Occupied);
    }
}